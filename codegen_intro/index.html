<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Introduction to Code Generation in RepreZen API Studio</title>
  <meta name="description" content="">

  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
  <!-- Latest compiled and minified CSS -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <!-- Optional theme -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap-theme.min.css" integrity="sha384-fLW2N01lMqjakBkx3l/M9EahuwpSfeNvV63J5ezn3uZzapT0u7EYsXMjQV+0En5r" crossorigin="anonymous">

  <!-- Latest compiled and minified JavaScript -->
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>  

  <!-- add after bootstrap.min.css -->
  <link rel="stylesheet" href="https://cdn.rawgit.com/afeld/bootstrap-toc/v0.3.0/dist/bootstrap-toc.min.css">
  <!-- add after bootstrap.min.js -->
  <script src="https://cdn.rawgit.com/afeld/bootstrap-toc/v0.3.0/dist/bootstrap-toc.min.js"></script>

  <link rel="stylesheet" href="/docs/css/asciidoc.css">
  <link rel="stylesheet" href="/docs/css/toc.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">

  <script src="/docs/js/jquery.cookie.min.js"></script>
  <script src="/docs/js/jquery.navgoco.min.js"></script>
  <link rel="stylesheet" href="/docs/css/jquery.navgoco.css">

  <link rel="canonical" href="http://reprezen.github.io/docs/codegen_intro/">
  <link rel="alternate" type="application/rss+xml" title="RepreZen End-User Documentation" href="http://reprezen.github.io/docs/feed.xml">

  <script src="/docs/js/ready.js"></script>
</head>

  <body data-spy="scroll" data-targets="#toc">
    <div class="container">
      <div class="row">
	<div class="col-sm-2 sidemenu nav">
	  
<ul><li><a href="#" >Code Generation</a><ul><li><a href="/docs/codegen_intro/" >Introduction</a></li></ul></li><li><a href="#" >Training Videos</a><ul><li><a href="https://www.youtube.com/channel/UCNwqDgngCot722zwHse5UTg" target="_blank">RepreZen YouTube Channel</a></li><li><a href="#" >Working with RepreZen API Studio</a><ul><li><a href="https://www.youtube.com/watch?v=aYYChcU2oJI&list=PLLMXvAoF1MNYQUezbEEEFfL5Lt8EXTOSg" target="_blank"><em>Play All</em></a></li><li><a href="https://www.youtube.com/watch?v=aYYChcU2oJI&index=1&list=PLLMXvAoF1MNYQUezbEEEFfL5Lt8EXTOSg" target="_blank">Introducing RepreZen API Studio</a></li><li><a href="https://www.youtube.com/watch?v=UsrsyEVO914&index=2&list=PLLMXvAoF1MNYQUezbEEEFfL5Lt8EXTOSg" target="_blank">Getting Started with RepreZen API Studio & Swagger</a></li><li><a href="https://www.youtube.com/watch?v=KX_tHp_KQkE&index=3&list=PLLMXvAoF1MNYQUezbEEEFfL5Lt8EXTOSg" target="_blank">Editing Swagger-OpenAPI in RepreZen API Studio</a></li><li><a href="https://www.youtube.com/watch?v=sSIX-A4ru7E&index=4&list=PLLMXvAoF1MNYQUezbEEEFfL5Lt8EXTOSg" target="_blank">Test-drive your Swagger-OpenAPI model in RepreZen API Studio</a></li><li><a href="https://www.youtube.com/watch?v=fiEDGvT0Y3I&index=5&list=PLLMXvAoF1MNYQUezbEEEFfL5Lt8EXTOSg" target="_blank">Getting Started with RAPID-ML</a></li><li><a href="https://www.youtube.com/watch?v=HeQrQje8lww&index=6&list=PLLMXvAoF1MNYQUezbEEEFfL5Lt8EXTOSg" target="_blank">RAPID-ML - Data Modeling Essentials for API Design</a></li><li><a href="https://www.youtube.com/watch?v=7F-EooNc9Q0&index=7&list=PLLMXvAoF1MNYQUezbEEEFfL5Lt8EXTOSg" target="_blank">Realization Modeling with RAPID-ML</a></li></ul></li><li><a href="#" >RAPID-ML</a><ul><li><a href="https://www.youtube.com/watch?v=fiEDGvT0Y3I&index=1&list=PLLMXvAoF1MNYNOly-N_M34LPH-5PlsTHO" target="_blank">Getting Started with RAPID-ML</a></li><li><a href="https://www.youtube.com/watch?v=HeQrQje8lww&index=2&list=PLLMXvAoF1MNYNOly-N_M34LPH-5PlsTHO" target="_blank">RAPID-ML - Data Modeling Essentials for API Design</a></li><li><a href="https://www.youtube.com/watch?v=7F-EooNc9Q0&index=3&list=PLLMXvAoF1MNYNOly-N_M34LPH-5PlsTHO" target="_blank">Realization Modeling with RAPID-ML</a></li><li><a href="https://www.youtube.com/watch?v=wYimccfMbAo&index=4&list=PLLMXvAoF1MNYNOly-N_M34LPH-5PlsTHO" target="_blank">Introducing the RAPID-ML Ready! API Plugin</a></li></ul></li></ul></li></ul>

	</div>
	<div class="col-sm-9">
	  <h1>Introduction to Code Generation in RepreZen API Studio</h1>
	  <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>The code generation features of RepreZen API Studio create the bridge between richly specifying an API and building systems that use that API properly.</p>
</div>
<div class="paragraph">
<p>A number of generators are built into the product and can be used immediately in any model project. Examples include (HTML) Documentation, Diagram,
Swagger, JSON Schema, XML Schema, and many others. And since our goal is to make RepreZen&#8217;s unique approach to modeling as widely adoptable as possible,
we will be adding more built-in generators in the future.</p>
</div>
<div class="paragraph">
<p>However, it is also possible&#8201;&#8212;&#8201;and relatively straightforward&#8201;&#8212;&#8201;to create and share custom generators for your own needs.</p>
</div>
<div class="paragraph">
<p>In this document we will cover basic concepts and see how to use code generation in RepreZen API Studio. We&#8217;ll cover how to perform common tasks using wizards and
other features of RepreZen API Studio, and we&#8217;ll create a custom code generator to address a fictional but plausible requirement in a large enterprise.</p>
</div>
<div class="paragraph">
<p>We&#8217;ll finish with a brief run-down of some advanced features that will allow experienced Java developers to create more powerful generators.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="the-generator-architecture">The Generator Architecture</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This figure shows the main parts of the RepreZen API Studio code generation framework.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="../images/codegen/arch.png" alt="Code Generation Architecture">
</div>
</div>
<div class="paragraph">
<p>Components in this framework include:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">GenEngine </dt>
<dd>
<p>A GenEngine encompasses facilities built into RepreZen API Studio to support a specific code
generation technology, such as a templating engine. RepreZen API Studio currently comes with a single GenEngine,
which supports the <a href="http://xtend-lang.org" target="_blank">Xtend</a> templating language.<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnote_1" title="View footnote.">1</a>]</sup></p>
<div class="paragraph">
<p>GenEngines are not currently implemented in a way that makes it feasible for end users to create
their own. We hope to provide GenEngines for other popular generation tools in the future.</p>
</div>
</dd>
<dt class="hdlist1">GenTemplate </dt>
<dd>
<p>A GenTemplate is an implementation of a code generator using a particular
GenEngine. Each GenTemplate produces output for a specific purpose, in a form suited to that
purpose. The generators that are built into RepreZen API Studio are all GenTemplates built using the Xtend
GenEngine.<sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnote_2" title="View footnote.">2</a>]</sup></p>
</dd>
<dt class="hdlist1">GenTarget </dt>
<dd>
<p>A GenTarget applies a GenTemplate to a model. When you create a GenTarget, it becomes
part of the model project.</p>
<div class="paragraph">
<p>Executing a GenTarget causes the associated GenTemplate to be executed against the associated model,
with the results appearing as files in the model project, in a folder specified by the GenTarget.</p>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>As stated earlier, RepreZen API Studio comes with numerous built-in generators. We can now state that with a bit
more precision: RepreZen API Studio comes with a number of built-in GenTemplates, each based on the Xtend
GenEngine. Likewise, when we stated that developers could create their own customized generators,
that really meant that developers can easily create and use their own GenTemplates, also based on
the Xtend GenEngine.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reprezen-api-studio-wizards">RepreZen API Studio Wizards</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this section we will walk through a few scenarios to introduce the wizards and other controls
built into RepreZen API Studio that relate to code generation.</p>
</div>
<div class="sect2">
<h3 id="reprezen-project">RepreZen Project</h3>
<div class="paragraph">
<p>The first wizard you are likely to encounter in RepreZen API Studio is the RepreZen Project wizard, which is one of
the choices presented in the <em>New</em> &#8594; <em>Project&#8230;&#8203;</em> dialog. Selecting <em>RepreZen API Studio</em> / <em>RepreZen Project</em> in
that dialog brings up the following window:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="../images/codegen/rep-proj-wizard.png" alt="RepreZen Project Wizard">
</div>
</div>
<div class="paragraph">
<p>Note that we have selected the option to create a Zen Model as part of the project creation. As a
result, we have the opportunity to create an initial set of GenTargets for that model. If we were to
check the "Create GenTargets" option, we could then create all of the offered GenTargets for our new
model, or we could use the "Add" and "Remove" buttons to customize the list. The initial list
contains some of the most popular GenTargets, but others will show up in the "Add" list&#8201;&#8212;&#8201;including
any custom GenTemplates that are available.</p>
</div>
<div class="paragraph">
<p>For this walk-through, we will select the Documentation and Swagger GenTargets.</p>
</div>
<div class="paragraph">
<p>Once we have created the project, if we fully expand the folder tree in the Project Explorer, we see
the following:</p>
</div>
<div class="openblock float-group">
<div class="content">
<div class="imageblock left rel thumb">
<div class="content">
<img src="../images/codegen/proj-structure.png" alt="RepreZen Project Structure">
</div>
</div>
<div class="paragraph">
<p>Here we see two top-level folders named <code>gentargets</code> and <code>models</code>. Naturally enough, the
<code>MyModel.zen</code> file, which is where we will define our model, landed in the <code>models</code> folder, and we
see both our initial GenTargets in the <code>MyModel</code> sub-folder of <code>gentargets</code>. The reason for the
sub-folder is that each GenTarget applies to a specific model, and there might be multiple models in
a single RepreZen project. In this case, we only have a single model named <code>MyModel</code>, and both targets
apply to it.</p>
</div>
<div class="paragraph">
<p>Each GenTarget is represented as a folder with three files: <code>build.gradle</code>, <code>pom.xml</code>, and a <code>.gen</code>
file named after the GenTarget&#8217;s associated GenTemplate.</p>
</div>
<div class="paragraph">
<p>The <code>build.gradle</code> and <code>pom.xml</code> files support command-line execution of their containing GenTargets
(also known as "headless" code generation), using popular build tools
<a href="http://gradle.org/" target="_blank">Gradle</a> and <a href="https://maven.apache.org/" target="_blank">Maven</a>,
respectively. Headless execution is not covered in this guide, but it is fully documented in the
{cgfordev}. That document also describes how to modify a GenTarget&#8217;s configuration by editing its
<code>.gen</code> file.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="executing-a-gentarget">Executing a GenTarget</h3>
<div class="paragraph">
<p>There are a couple of standard ways to execute GenTargets. First is the "Generate GenTargets"
drop-down menu in the RepreZen API Studio tool bar:</p>
</div>
<div class="openblock float-group">
<div class="content">
<div class="paragraph">
<p><span class="image left rel thumb"><img src="../images/codegen/gen-menu.png" alt="Generate GenTargets Menu"></span></p>
</div>
<div class="paragraph">
<p>You can select any of the listed options, and the corresponding GenTarget (or all of them if you
select the first option) will be executed.</p>
</div>
<div class="paragraph">
<p>The other way to execute a GenTarget is from the context menu of the GenTarget in the Project
Explorer.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s run the Swagger GenTarget and see what happens to our project. Here&#8217;s the fully-expanded
Project Explorer pane after the GenTarget has completed:</p>
</div>
<div class="openblock float-group">
<div class="content">
<div class="imageblock left rel thumb">
<div class="content">
<img src="../images/codegen/proj-structure-after-gentarget.png" alt="Project Structure After GenTarget">
</div>
</div>
<div class="paragraph">
<p>Here we see a new folder, <code>generated</code>, under the <code>Swagger</code> GenTarget. This is where the files
generated by the GenTarget are placed by default. We see here that the Swagger GenTemplate creates
two output files, due to Swagger&#8217;s support for both JSON and YAML formats.</p>
</div>
<div class="paragraph">
<p>In addition, we see a new file, <code>Swagger.trace.json</code>, that was also created under the <code>Swagger</code>
GenTarget, but it&#8217;s not in the <code>generated</code> folder. This file contains <em>trace</em> information, which is
discussed in the {cgfordev}.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>If we now execute the Documentation GenTarget, we&#8217;ll see an additional twist. Here&#8217;s the partially
expanded project tree that results:</p>
</div>
<div class="openblock float-group">
<div class="content">
<div class="imageblock left rel thumb">
<div class="content">
<img src="../images/codegen/proj-structure-doc-gen.png" alt="Project Structure After Document GenTarget">
</div>
</div>
<div class="paragraph">
<p>As expected, we now have a <code>generated</code> folder under the <code>Documentation</code> GenTarget, as well as a
trace file. The file that was actually generated from our RepreZen model is <code>MyModel_doc.html</code>. But
there are other items in the <code>generated</code> folder.</p>
</div>
<div class="paragraph">
<p>It turns out that the HTML generated by the Documentation GenTarget relies on a number of web
assets, including images, CSS stylesheets, and Javascript files. None of these depends on our model,
hence they were not really <em>generated</em>. Instead, they were copied from an identical structure baked
into the Documentation GenTemplate itself. Files that are copied in this fashion are called <em>static
resources</em>.</p>
</div>
<div class="paragraph">
<p>The {cgfordev} fully describes how to add static resources to a GenTemplate.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>In general, each GenTemplate defines any number of dynamic templates, and any number of static
resources. Each template gives rise to a single file, and each resource gives rise to a
folder. These output files and folders are all placed in the GenTarget&#8217;s output folder, which by
default is a sub-folder named <code>generated</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="adding-a-gen-target-and-resolving-dependencies">Adding a Gen Target (and Resolving Dependencies)</h3>
<div class="openblock float-group">
<div class="content">
<div class="imageblock left rel thumb">
<div class="content">
<img src="../images/codegen/new-gentarget-tool.png" alt="Create a New Generation Target Tool">
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s look at how we can add GenTargets to an existing model. The easiest way is to click on the
"Create a New Generation Target" tool in the RepreZen API Studio tool bar while we&#8217;re editing a model file or when
a model file is active in the Project Explorer pane. We can also select <em>New</em> / <em>GenTarget</em> from the
context menu when right-clicking a model file in the Project Explorer pane.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>This will bring up the following dialog box, where we can choose which GenTarget we wish to add.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="../images/codegen/new-gentarget-dialog.png" alt="New Generation Target Dialog">
</div>
</div>
<div class="paragraph">
<p>We&#8217;ll select the WADL GenTemplate for our new GenTarget, and when we do that we notice that the
"Next" button in the dialog box suddenly became active. That won&#8217;t happen with every GenTemplate,
and we can see what it means by clicking on the "Next" button, leading to another dialog:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="../images/codegen/WADL-dependencies-dialog.png" alt="WADL Dependencies Dialog">
</div>
</div>
<div class="paragraph">
<p>This dialog is alerting us to the fact that the WADL GenTarget requires an XML Schema GenTemplate on
the same model as a prerequisite.</p>
</div>
<div class="paragraph">
<p>GenTarget dependencies arise from GenTemplate Dependencies. If GenTemplate A has a dependency on
GenTemplate B, it means that one of the input files required by A is an output produced by B. Any
such dependency between GenTemplate gives rise to an analogous dependency among GenTargets. Details
about GenTemplate dependencies are provided in the {cgfordev}. Here we will confine ourselves to
understanding how GenTargets can be created when dependencies arise.</p>
</div>
<div class="paragraph">
<p>Whenever you attempt to create a GenTarget with dependencies, you are asked to decide whether and
how to <em>resolve</em> those dependencies&#8201;&#8212;&#8201;that is, identify or create other GenTargets to satisfy those
dependencies. There are three possible resolution strategies that may appear in the selection menu
appearing for each dependency listed in the GenTarget dependency dialog:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">New GenTarget </dt>
<dd>
<p>This option causes the creation of a new GenTarget to resolve the
dependency. Selecting this option will cause another instance of the New Generation Target dialog to
pop up immediately, already configured with the correct GenTemplate and other defaults. If that
GenTarget also has dependencies, the new dialog will itself have an active "Next" button that could
be used to create yet more new GenTargets, and so forth.</p>
</dd>
<dt class="hdlist1">Do Not Resolve </dt>
<dd>
<p>This option defers resolution until some other time. Until that happens, the
GenTarget is likely to fail. Unfortunately, there is currently no wizard-based help for resolving a
deferred dependency at a later point in time. Therefore users who are not interested in learn the
inner workings of GenTarget configuration (e.g. by perusing the {cgfordev}) are encouraged to avoid
this option. Unfortunately, this is the default option when no existing GenTarget can satisfy the
dependency, so failing to click "Next" in the initial dialog will result in a GenTarget that likely
will not work.</p>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
"Do Not Resolve" is currently the default resolution strategy when no conforming GenTarget
already exists. Users are encouraged to avoid clicking "Finish" on the first dialog box if the
"Next" button is active, since that will apply these defaults. Rather the user should click "Next"
to view the dependencies and ensure that none of the dependencies has "Do Not Resolve" as a
resolution strategy.
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1">Use an Existing GenTarget </dt>
<dd>
<p>If a GenTarget already exists for the model that is of the type
required by some dependency, that GenTarget will also appear as a resolution option for that
dependency.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>We&#8217;ll select the "New GenTarget" option in the selection menu. When we do that, we will immediately
see new a dialog box that will allow us create a new XML Schema GenTarget. The existing dialog for
the WADL GenTarget is still visible, but it is inoperable until the new dialog closes out. We will
accept all the default settings for our new XML Schema GenTarget by clicking its "Finish"
button. Then we can also click "Finish" on the WADL GenTarget dialog. When we&#8217;re finished, we will
see that both the WADL GenTarget we originally requested and the XML Schema GenTarget it depends on
have been added to our model project for the <code>MyModel</code> model.</p>
</div>
</div>
<div class="sect2">
<h3 id="creating-a-gen-template">Creating a Gen Template</h3>
<div class="paragraph">
<p>So far we have seen how to set up built-in GenTargets to generate various types of output in our
model projects. But how about if we have a special need. For example, imagine we work at a company
that maintains a proprietary lexicon of named elements appearing in APIs throughout the
organization, including data types, resources, properties, etc. Perhaps this lexicon is richly
linked, and consumes CSV files submitted by various projects. We&#8217;d like to contribute information
about our RepreZen models. We could automate the creation of our CSV files by creating a custom
GenTemplate.</p>
</div>
<div class="paragraph">
<p>To get started, we&#8217;ll use the <code>Xtend Generation Template</code> wizard in RepreZen API Studio. Select <em>New</em> &#8594;
<em>Other&#8230;&#8203;</em>, and then choose <em>RepreZen API Studio</em> / <em>Generation Templates</em> / <em>Xtend Generation Template</em>. The
following dialog will appear:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="../images/codegen/new-gen-template-dialog.png" alt="New Gen Template Wizard">
</div>
</div>
<div class="paragraph">
<p>Notice that we&#8217;re asked to provide a project name. It turns out that GenTemplates cannot easily live
within a model project, so even if we had invoked <em>New</em> from the context menu of our <code>MyModel</code>
project, this box would be empty. And we wouldn&#8217;t be permitted to type in "MyModel" to use the
<code>MyModel</code> project even if we wanted to. Instead, we&#8217;ve chosen the name <code>LexiconGenTemplates</code> for our
project, which suggests that we may create multiple GenTemplates related to the lexicon over
time. As it turns out, this project name will also become the name of our single GenTemplate in this
project.<sup class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnote_3" title="View footnote.">3</a>]</sup></p>
</div>
<div class="paragraph">
<p>When we click <code>Finish</code>, our new project is created, and RepreZen API Studio busies itself in building the initial
code that it creates for us. Let&#8217;s see what the project looks like:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="../images/codegen/gen-template-project-structure.png" alt="Gen Template Project Structure">
</div>
</div>
<div class="paragraph">
<p>The only thing we&#8217;re going to pay attention to right now is <code>MainTemplate.xtend</code>. This is the file
that will define the "meat" of our GenTemplate. Nearly all the rest of the project content is
boilerplate that you won&#8217;t need to worry about unless you choose to modify your GenTemplate in ways
that go beyond what the wizard provides.</p>
</div>
<div class="paragraph">
<p><code>MainTemplate.xtend</code> is an Xtend source file. As stated earlier, Xtend is a programming language
that is based on Java but includes numerous extensions. Here we will be looking at only one of those
extensions: the Xtend templating language. Even if you have little programming experience, you can
create many useful Xtend GenTemplates without learning more about Xtend than we will cover here. If
you would like to learn more, see the <a href="https://eclipse.org/xtend/documentation/">Xtend documentation</a>.</p>
</div>
<div class="sect3">
<h4 id="a-look-at-the-initial-template">A Look At the Initial Template</h4>
<div class="paragraph">
<p>If we click on <code>MainTemplate.xtend</code> in the Project Explorer, we will see the source code in the main
panel of RepreZen API Studio. We&#8217;ll take a look at that code, but just as much of what appears in the overall
GenTemplate project is boilerplate, so also is some of the code in this file. We will currently
restrict our attention purely to the Xtend template that appears within the file:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="../images/codegen/xtend-initial-template.png" alt="Initial Xtend Template">
</div>
</div>
<div class="paragraph">
<p>The template starts and ends with three consecutive apostrophes. The initial content of the template
will generate a very simple HTML file that includes the name of your model in its title and displays
bulleted list of the resource APIs defined in your model. Of course, that&#8217;s not what we need for our
Lexicon export, but the wizard has provided a working example that we can change to suit our
needs. We&#8217;ll use it to take our first look at Xtend, and then we&#8217;ll replace it with the template we
need for our CSV file.</p>
</div>
<div class="paragraph">
<p>Most of the content of the template is simply copied to the output file created by the GenTarget,
as-is. However, embedded in the template are constructs that are set off by left and right
<em>guillemet</em> characters (&laquo; and &raquo;). These constructs are <em>not</em> copied to the output;
rather, they cause dynamic content to be emitted in their place. In addition, Xtend uses triplets of
guillemets to enclose code comments, e.g.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-xtend" data-lang="xtend">«««This is an Xtend comment and will have no impact on the template output»»»</code></pre>
</div>
</div>
<div class="paragraph">
<p>Two different types of templating construct appear in this template: an "interpolation" and a
loop. Xtend also offers an if-then-else construct. Let&#8217;s look at examples of the two types of
construct in the starter template.</p>
</div>
<div class="paragraph">
<p>First, we have interpolation, which is just a fancy word meaning that the entire construct will be
replaced by the <em>value</em> of whatever is between the guillemets. In general, any valid Xtend
expression (and that includes most valid Java expressions) can appear in an interpolation. The value
of that expression will appear in the output to take the place of the interpolation construct.</p>
</div>
<div class="paragraph">
<p>In our case, we have <code>&laquo;model.name&raquo;</code>. When RepreZen API Studio applies this template to a model, a
variable named <code>model</code> will represent the model itself, in the form of an object of type
<code>ZenModel</code>. The <code>ZenModel</code> class contains a number of properties, one of which is the model&#8217;s
name. The Xtend expression <code>model.name</code> yields the model&#8217;s name, and that name is what replaces
<code>&laquo;model.name&raquo;</code> in the output file. Therefore, if we use this GenTemplate on the model we
created above, the generated HTML file will have as its title "Sample Generated HTML for MyModel,"
thanks to the interpolation construct on line 12.</p>
</div>
<div class="paragraph">
<p>Next, we have two instances of the Xtend loop construct, one covering lines 18-22, and another
nested within the first, spanning lines 19-21. Let&#8217;s look at these two loops in detail:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-xtend" data-lang="xtend">«FOR resourceAPI : model.resourceAPIs»                      <i class="conum" data-value="1"></i><b>(1)</b>
  «FOR resource : resourceAPI.ownedResourceDefinitions»     <i class="conum" data-value="2"></i><b>(2)</b>
    &lt;li&gt;«resource.name»&lt;/li&gt;                                <i class="conum" data-value="3"></i><b>(3)</b>
  «ENDFOR»                                                  <i class="conum" data-value="4"></i><b>(4)</b>
«ENDFOR»                                                    <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 85.7143%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="conum" data-value="1"></strong> thru <strong class="conum" data-value="5"></strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>The outer loop introduces the variable <code>resourceAPI</code> and binds it in turn to each of the values
appearing in the collection represented by <code>model.resourceAPIs</code>. Just like <code>name</code>, <code>resourceAPIs</code> is
a property of the <code>ZenModel</code> class, and <code>model.resourceAPIs</code> is an expression that accesses it. The
property&#8217;s vlaue is a collection of values of type <code>ResourceAPI</code>, and the collection includes all
the <code>resourceAPI</code> definitions appearing in our model.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
We haven&#8217;t made any changes to our model since creating it, and the RepreZen API Studio Project Wizard
created it as a working sample model with one resource API, named <code>MyModelAPI</code>.
</td>
</tr>
</table>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="conum" data-value="2"></strong> thru <strong class="conum" data-value="4"></strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>The second loop introduces a new variable, <code>resource</code>, that will represent, in turn, each of the
resources defined in whichever resource API is currently represented by the <code>resourceAPI</code>
variable. These are obtained via the <code>ownedResourceDefinitions</code> property of the <code>ResourceAPI</code> class.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In the sample model created by RepreZen API Studio, the <code>MyResourceAPI</code> resource API includes two resources:
an object resource named <code>MyModelObject</code>, and a collection resource named <code>MyModelCollection</code>.
</td>
</tr>
</table>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong class="conum" data-value="3"></strong></p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>Finally, we have an interpolation construct that emits the name of whichever resource is currently
 bound to the <code>resource</code> variable, as a list item.</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The upshot of these two loops is that the names of all the resources defined by all the resource
APIs in our model will appear in an itemized list. In our case, in our untouched model, we have a
single resource API named <code>MyModelAPI</code>, with two resources named <code>objectResource</code> and
<code>collectionResource</code>. Our itemized list will contain those two resource names.</p>
</div>
</div>
<div class="sect3">
<h4 id="but-what-about-our-lexicon">But What About Our Lexicon?</h4>
<div class="paragraph">
<p>Our goal was not to create an HTML list of resource names, but to generate data to be fed into our
enterprise lexicon. So let&#8217;s remove the initial template created for us by the wizard, and create
the template we really want.</p>
</div>
<div class="paragraph">
<p>Our first job is to remove the contents of the existing template&#8201;&#8212;&#8201;that is, everything between the
opening triple-apostrophe and the closing triple-apostrophe. We can also remove the comment that the
GenTemplate Wizard left us pointing at the Xtend documentation.  We&#8217;re left with something that
looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>override generate(ZenModel model) {
    '''
    '''
 }</pre>
</div>
</div>
<div class="paragraph">
<p>Before we go any further, we should change the configuration of our GenTemplate so that it will
generate files with names like <code>MyModel.csv</code> instead of <code>MyModel.html</code>. That&#8217;s specified in a file
named <code>config.json</code> that appears in the same folder as the <code>MainTemplate.xtend</code> file that we&#8217;ve been
working on. Go ahead and open it in RepreZen API Studio.</p>
</div>
<div class="paragraph">
<p>The <code>config.json</code> file provides configuration information for our GenTemplate, in a format known as
<a href="http://www.json.org/">JSON</a>. Our output file name is configured on the following line:</p>
</div>
<div class="listingblock java">
<div class="content">
<pre class="highlight nowrap"><code>"outputFile": "${zenModel.name}.html"</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can directly change the <code>html</code> at the end of this lineto <code>csv</code>, being careful not to dirsupt
anything else in the line, including the final quote. In the end the file should look like this.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-java" data-lang="java">{
    "primarySource": {
        "type": "com.modelsolv.reprezen.generators.api.zenmodel.ZenModelSource",
        "description": "RAPID-ML model for generation"
    },
    "outputItems": [
        {
            "name": "MainTemplate",
            "type": "com.modelsolv.reprezen.generators.xtend.template.lexicongentemplates.MainTemplate",
	        "outputFile": "${zenModel.name}.csv"
        }
    ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once you are finished, save your changes and go back to the editor where we were working on
<code>MainTemplate.xtend</code>.</p>
</div>
<div class="paragraph">
<p>Now let&#8217;s start filling in what we really intend to show up in our generated CSV file. For starters,
lets assume that our file will contain an initial row containing column names. This requires nothing
more than typing the text of that line directly into our template:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-xtend" data-lang="xtend">override generate(ZenModel model) {
  '''
    Name,Type,Parent,ParentType,Model,Documentation
  '''
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Xtend has rules that determine which white-space (blanks, line ends, etc.) are copied from the
template to the output. Initial indentation is not copied, so in our output, "Name" will appear in
the first column. In addition, our initial new line will be omitted. For details see the
<a href="http://www.eclipse.org/xtend/documentation/203_xtend_expressions.html#templates">Xtend template
documentation</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now let&#8217;s start filling in some information from our model. We&#8217;ll start with a record for our model
as a whole, by adding the following line to our template:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-xtend" data-lang="xtend">«model.name»,Model,,,«model.name»,</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
To insert guillemets in RepreZen API Studio, hold the Control key down while hitting the space bar. If that
doesn&#8217;t work, it&#8217;s probably because your insertion point is not positioned in a place where a pair
of guillemets would make sense. You can also press "&lt;" or "&gt;" while holding down the Control key to
insert left or right guillemet, regardless of whether that makes sense. <span class="icon"><i class="fa fa-smile-o"></i></span> (These do not
appear to work on OS X.)
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Our model name will appear in the first column of this record, and "Model" will appear in the
second. Our model has no parent, so the parent fields are left blank. The model in which our model
appears is, of course, our model; so we repeat the model name in the "Model" column. There is
currently no way to provide any overall documentation for a RepreZen model as a whole, so the
documentation column is blank.</p>
</div>
<div class="paragraph">
<p>Next, we&#8217;ll create records for all the resource APIs defined in our model, using the same
<code>resourceAPIs</code> property of <code>ZenModel</code> as we saw in the initial template:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-xtend" data-lang="xtend">«FOR resourceAPI: model.resourceAPIs»
  «resourceAPI.name»,ResourceAPI,«model.name»,Model,«model.name»,«resourceAPI.documentation.text»
«ENDFOR»</code></pre>
</div>
</div>
<div class="paragraph">
<p>Everything should be fairly self-explanatory in this line, but there is a problem. If any resource
API is missing documentation, this GenTemplate will fail. The problem is that in that case,
<code>resourceAPI.documentation</code> will have a null value, and therefore, trying to retrieve its <code>text</code>
property will fail. We&#8217;ll ignore this issue for now, but we&#8217;ll address it <a href="#Fixing the Documentation
Issue">later</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The sample model created by the RepreZen Project wizard does not include any documentation
comments, so the <code>Documentation</code> column will always be empty, even once we fix the documentation
issue. You can add comments of the form <code>/** documentation here */</code> in front of many of the model
elements, and they will be picked up by our template.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We also want records for all the resources defined for each resource API. For this we&#8217;ll want
another loop, nested within the one listed above. This is the same strategy as we saw in the initial
template. We&#8217;ll use something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-xtend" data-lang="xtend">«FOR resource: resourceAPI.ownedResourceDefinitions»
  «resource.name»,???,«resourceAPI.name»,ResourceAPI,«model.name»,«resource.documentation.text»
«ENDFOR»</code></pre>
</div>
</div>
<div class="paragraph">
<p>Everything looks normal here except the value we&#8217;re placing in the <code>Type</code> column, which appears as
"???" above. The problem is that we can&#8217;t just use a fixed value like <code>ResourceAPI</code>, as we did for
the resource API record, because resources come in two varieties: object resources and collection
resources. Here we can make use of the Xtend if-then-else construct, as in:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-xtend" data-lang="xtend">«IF resource instanceof CollectionResource»
  CollectionResource
«ELSEIF resource instanceof ObjectResource»
  ObjectResource
«ENDIF»</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we inserted the above into our template, we&#8217;d get the right values&#8201;&#8212;&#8201;"CollectionResource" or
"ObjectResource" according to the actual type of the resource&#8201;&#8212;&#8201;in our CSV file. However, in its
current form, it would also introduce line breaks that would mess up our CSV file. In most cases,
Xtend "does the right thing" with white space and line breaks appearing in templates. But
occasionally we need to take direct control.</p>
</div>
<div class="paragraph">
<p>One way would be to crush the entire if-then-else construct into a single line:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-xtend" data-lang="xtend">«IF resource instanceof CollectionResource»CollectionResource«ELSEIF resource instanceof ObjectResource»ObjectResource«ENDIF»</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will work, but it&#8217;s pretty ugly and hard to understand, especially since we need to stick that
whole thing into the middle of an already complicated line in our template. An alternative is to
place the guillemet characters strategically so that all the line breaks in our template occur
<em>within</em> the guillemets, like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-xtend" data-lang="xtend">«IF resource instanceof CollectionResource
  »CollectionResource«
ELSEIF resource instanceof ObjectResource
  »ObjectResource«
ENDIF»</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will work just fine, but it still will look pretty bad when we cram it into our overall
template. Thankfully, Xtend is embedded in the powerful Java programming language, so we can do
things like defining methods to handle tasks like what our if-then-else snippet is doing. Here&#8217;s how
that looks in Xtend:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-xtend" data-lang="xtend">def getType(ResourceDefinition resource) {
  '''«
    IF resource instanceof CollectionResource
      »CollectionResource«
    ELSEIF resource instanceof ObjectResource
      »ObjectResource«
    ENDIF
  »'''
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;ve now created a method called <code>getType</code> that we can apply to any resource, and it will yield the
type string that we&#8217;re after. The method itself is defined using an Xtend template, but the result
of evaluating the template is not written directly to our output file, as is the case with our main
template. Instead, this method will apply the template and return the results, which we can
incorporate in our main template via interpolation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-xtend" data-lang="xtend">«FOR resource: resourceAPI.ownedResourceDefinitions»
  «resource.name»,«resource.type»,«resourceAPI.name»,ResourceAPI,«model.name»,«resource.documentation.text»
«ENDFOR»</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You may notice that we have <code>resource.type</code> in our template, not <code>resource.getType</code>. If we name
a method something like <code>getXxx</code> it can be invoked from an object as if it were a property of that
object, named <code>xxx</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We will stop here, but we could, if we wished, continue navigating through our model to emit
additional items for our lexicon, including resource methods and their parameters, data types and
their properties, and so forth.</p>
</div>
<div class="sect4">
<h5 id="fixing-the-documentation-issue">Fixing the Documentation Issue</h5>
<div class="paragraph">
<p>Now let&#8217;s fix that problem we had with documentation. To recap, the expression we want to use to
access it, <code>xxx.documentation.text</code>, causes the entire template to fail if the documentation is
missing. In that case <code>xxx.documentation</code> has the value <code>null</code>, and <code>null</code> has no properties, let
alone a <code>text</code> property.</p>
</div>
<div class="paragraph">
<p>We can off-load the task of obtaining documentation to a separate method, which we will design so
that it works on any object that implements the <code>Documentable</code> interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-xtend" data-lang="xtend">def getDoc(Documentable item) {
  '''«IF item.documentation !=null»«item.documentation.text»«ENDIF»'''
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then instead of the brittle <code>xxx.documentation.text</code>, we can use <code>xxx.doc</code> in our templates to yield
the documentation, if it exists, or nothing if it does not.</p>
</div>
</div>
<div class="sect4">
<h5 id="our-finished-template">Our Finished Template</h5>
<div class="paragraph">
<p>With this we can now show our final version of <code>MainTemplate.xtend</code>:</p>
</div>
<div class="imageblock text-centered">
<div class="content">
<img src="../images/codegen/final-lexicon-gentemplate-code.png" alt="Final Lexicon GenTemplate Code">
</div>
</div>
<div class="paragraph">
<p>Here it is in a form that can be copied and pasted (but is not as nicely formatted as the above), in
case you want to use it to try things out in RepreZen API Studio:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-xtend" data-lang="xtend">package com.modelsolv.reprezen.generators.xtend.template.lexicongentemplates

import com.modelsolv.reprezen.generators.api.zenmodel.ZenModelOutputItem
import com.modelsolv.reprezen.restapi.CollectionResource
import com.modelsolv.reprezen.restapi.Documentable
import com.modelsolv.reprezen.restapi.ObjectResource
import com.modelsolv.reprezen.restapi.ResourceDefinition
import com.modelsolv.reprezen.restapi.ZenModel

class MainTemplate extends ZenModelOutputItem {
    override generate(ZenModel model) {
        '''
            Name,Type,Parent,ParentType,Model,Documentation
            «model.name»,Model,,,«model.name»,
            «FOR resourceAPI : model.resourceAPIs»
                «resourceAPI.name»,ResourceAPI,«model.name»,Model,«model.name»,«resourceAPI.doc»
                «FOR resource : resourceAPI.ownedResourceDefinitions»
                    «resource.name»,«resource.type»,«resourceAPI.name»,ResourceAPI,«model.name»,«resource.doc»
                «ENDFOR»
            «ENDFOR»
        '''
    }

    def getType(ResourceDefinition resource) {
        '''«
            IF resource instanceof CollectionResource
                »CollectionResource«
            ELSEIF resource instanceof ObjectResource
                »ObjectResource«
            ENDIF
        »'''
    }

    def getDoc(Documentable item) {
        '''«IF item.documentation != null»«item.documentation.text»«ENDIF»'''
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You may notice that the part of this file that we have been ignoring (outside the template and our
added functions) has changed. There are more <code>import</code> statements than there used to be. These are
required because we introduced into our code references to types like <code>ReferenceAPI</code>,
<code>ResourceDefinition</code>, etc. The <code>import</code> statements are what enable the Xtend (and Java) compiler to
know what to make of these types. The easiest way to manage imports is using a built-in feature of
RepreZen API Studio to fix your imports whenever you reference a type that is not already imported. Just type "O"
(the letter) while holding down the Control and Shift keys (Command and Shift on OS X). Until you
do this, your project will show errors involving the types we introduced, and you won&#8217;t be able to
use your GenTemplate.</p>
</div>
<div class="paragraph">
<p>Once we have this GenTemplate defined, we can add a corresponding GenTarget to our model just as we
did earlier when adding the WADL GenTarget. This time, the dialog box will include our new
GenTemplate, named <code>LexiconGenTemplates</code>.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="../images/codegen/add-gentarget-dialog.png" alt="Add GenTarget Dialog">
</div>
</div>
<div class="paragraph">
<p>You can now execute that GenTarget, and you should find the file <code>MyModel.csv</code> in the <code>generated</code>
folder for that template, with the following contents:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-csv" data-lang="csv">Name,Type,Parent,ParentType,Model,Documentation MyModel,Model,,,MyModel,
MyModelAPI,ResourceAPI,MyModel,Model,MyModel,
MyModelObject,ObjectResource,MyModelAPI,ResourceAPI,MyModel,
MyModelCollection,CollectionResource,MyModelAPI,ResourceAPI,MyModel,</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
As mentioned earlier, the default model created by RepreZen API Studio does not include any documentation, so
the <code>Documentation</code> column is empty in this file. However, if you were to add documentation to the
<code>MyModelAPI</code> resource API or to either of its resources, you would see that documentation in the
resulting file.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
We have not taken care to quote items in our generated CSV file, so if we had commas or
multiple lines in any documentation string, we would end up with a broken or unreadable CSV file. We
could quite easily extend our <code>getDoc</code> method to properly quote the documentation string no matter
what its contents.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnote_1">
<a href="#_footnoteref_1">1</a>. Note that the Xtend language is very nearly a superset of Java, so if you are a Java programmer you can use most of what you know in your Xtend classes. And you can intermingle pure Java classes at will, and use all available Java libraries with without any compatibility issues. This is guaranteed by the fact that Xtend classes are not actually compiled, but are rather transformed into pure Java classes, which are then compiled by the Java compiler.
</div>
<div class="footnote" id="_footnote_2">
<a href="#_footnoteref_2">2</a>. Building on the footnote regarding Xtend in the context of GenEngine, we can further point out that it is perfectly possible to code an Xtend GenTemplate completely in Java. Indeed, some of the GenTemplates built into RepreZen API Studio are pure Java.
</div>
<div class="footnote" id="_footnote_3">
<a href="#_footnoteref_3">3</a>. The {cgfordev} explains how to change the name of our GenTemplate, as well as how to create additional GenTemplates in the same project. The wizard presently is not currently capable of adding a GenTemplate to an existing project.
</div>
</div>
	</div>
	<div class="col-sm-1">
	  <nav id="toc" data-spy="affix" data-toggle="toc"></nav>
	</div>
      </div>
    </div>
    <footer class="site-footer">

  <div class="wrapper">

  </div>

</footer>

  </body>
</html>
