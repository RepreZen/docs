---
permalink: /swagger_normalizer/
---
= Using the Swagger Normalizer GenTemplate
:imagesdir: ../images/codegen
:linkattrs:
:docinfo2:
:RAS: RepreZen API Studio 
:RZ: RepreZen

Swagger Normalizer is a core component of the Swagger Multi-File
Support in {RAS}, and as such it is used by each of the three "`live`"
views - Documentation View, Diagram View, and Swagger UI View - that
appear by default in the right-hand pane of the {RAS} GUI, as well as
by all Swagger GenTemplates. You can also use it directly as its own
GenTemplate, named "`Swagger [Normalized YAML]`" in the GenTarget
Wizard. 

The primary function of the normalizer is to render a multi-file
Swagger spec as a functionally equivalent single-file spec. In this
way it can simplify the use of other tools and libraries in the
evolving Swagger ecosystem, where external references are not always
handled consistently.

Additionally, the normalizer can perform other transformations of the
Swagger spec, which may be helpful for some circumstances, especially
when feeding the spec to downstream systems.

== Basic Use

The Normalizer is used like any other Swagger GenTemplate:

1. Create a GenTarget (a `.gen` file) in your model folder, linking
your Swagger model file (`.yaml` file) to the GenTemplate. The
internal id of this GenTemplate is:
+
[source%nowrap]
--
com.modelsolv.reprezen.gentemplates.swaggernorm.SwaggerNormalizerGenTemplate
--
+
The name listed in the drop-down list in the GenTarget wizard is
"`Swagger [Normalized YAML].`"

2. Configure the GenTarget as desired (see below).

3. Execute the GenTarget

4. Find the generated YAML file in the `generated` folder that appears
in the GenTarget folder.

// Should have images walking through this process

== Multifile Processing

The one thing that the normalizer will always do is resolve external
references and leave you with a single-file Swagger Spec. The other
things it may do depend on options, described below.

=== References in Swagger Specs

Here's an example of what a typical _reference_ might look like in a
Swagger spec:

```
responses:
  200:
    description: Default Response
    schema:
      $ref: "#/definitions/Pet"
```

This is part of the definition of an operation whose normal response
will contain data about a pet. That information will be structured
according to a schema named `Pet` defined elsewhere in this same
Swagger spec, in the `definitions` section of the spec.

The reference itself appears as the value of the `schema` property in
the response. That property could appear with an "in-line" schema
definition, but in this case the designer has opted to define the
schema elsewhere and reference it here by name. The reference itself
takes the form of an object with a string-valued property named
`$ref`. footnote:[Local references like this one - that is references
to an object in the same file - always start with a pound sign:
"#". This happens to be the comment character in YAML syntax, so a
common error is to omit quotes around the reference string. This will
have the same effect as an empty string, which can lead to a variety
of problems with consumers of the model. Be careful to always use
quotes around your reference strings!]

If the definition of the `Pet` schema physically appeared in some
other Swagger spec, the reference would need to include a URL to
retrieve that spec, with a fragment identical to the reference string
shown above:

```
responses:
  200:
    description: Default Response
    schema:
      $ref: "http://models.example.com/petstore-schemas.yaml#/definitions/Pet"
```


TIP: Swagger's `$ref` syntax conforms to a separate standard known as
"JSON Reference." That standard is available
https://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03[here].

==== Swagger References vs. Fragment References

References in a Swagger spec should all be of the variety specifically
endorsed by the http://swagger.io/specification[Swagger
Specification], namely those with URI fragments that begin with
`\#/paths/` or `#/parameters/` or `\#/responses/` or
`#/definitions/`. We'll call those _Swagger references_. All other
references will be called _fragment references_. Swagger Normalizer
does not treat these two varieties of reference identically.

WARNING: Fragment references are not officially allowed in Swagger
specs, but some tooling permits their use, and there are, confusingly,
posted examples and tutorials from Swagger project contributors and
others that feature them.

====
Note:: The document identified by the pre-fragment portion of an
external Swagger reference _must_ be a valid Swagger spec. At a
minimum this means that it must include: (1) a string-valued `swagger`
property whose value is `2.0`; (2) an object-valued `info` property
that includes (3) a string-valued `title` property and (4) a
string-valued `version` property; and an object-valued `paths` object,
which may be empty (`{}`). A minimal compliant Swagger spec
footnote:[The {RAS} New Model Wizard offers a "Minimal" option that
will create a (nearly) minimal Swagger spec as a starting point.]
might look like this:

```
---
swagger: "2.0"     <1>
info:              <2>
  title: My title  <3>
  version: "1.0"   <4>
paths: {}          <5>
```
====

=== What Swagger Normalizer Does with References

When the normalizer encounters any reference, there are two ways it
may process the reference:

Inline:: The normalizer retrieves the referenced value (e.g. the `Pet`
schema definition object) and replaces the reference itself with that
value.

Localize:: The normalizer first adds the referenced object to the
normalized spec that it is creating, if it is not already present, and
then replaces the reference with a local reference to that object. So
in the external reference example shown above, the `Pet` schema
definition would appear directly in the Swagger spec produced by the
normalizer, and references that were formerly external references
would become local references.

The normalizer _always_ inlines fragment references. Any given Swagger
reference might be inlined or localized, depending on options in
effect.

==== Name Collisions

Localization of a Swagger reference may lead to a name collision. For
example, imagine the following excerpts from two Swagger specs:

[source%nowrap]
.main.yaml
----
defintions:
  Address:
    description: An address given by a speaker
    type: object
    properties:
      speaker:
         $ref: "external.yaml#/definitions/Person"
      title:
        type: string
      ...
----

[source%nowrap]
.external.yaml
----
defintions:
  Person:
    name:
       type: string
    address:
      $ref: "#/definitions/Address"
  Address:
    description: A postal address
    type: object
    properties:
      street:
        type: string
      ...
----

The main spec is apparently describing APIs related to events where
speakers deliver addresses. The speakers themselves are represented
using an externally referenced `Person` schema which itself makes use
of a locally referenced `Address` schema.

In a localizing scenario, the normalized spec created by the
normalizer would look something like this:

[source%nowrap]
.main-normalized.yaml
----
definitions:
  Address:
    description: An address given by a speaker
    type: object
    properties:
      speaker:
         $ref: "#/definitions/Person"   <1>
      title:
        type: string
      ...
  Person:
    name:
       type: string
    address:
      $ref: "#/definitions/Address_1"   <2>
  Address_1:
    description: A postal address
    type: object
    properties:
      street:
        type: string
      ...
----

The two `Address` schemas originally in _main.yaml_ and
_external.yaml_ are both needed in the normalized spec, but their
names collide. Therefore, the schema definition originally in
_external.yaml_ is renamed to `Address_1`.

All references have been adjusted as required:

<1> The former external reference to the `Person` schema is now a
local reference.
<2> The `Person` schema's `Address` reference now reflects the
renaming that occurred.

Renaming is done only where necessary due to a conflict, and the names
appearing in the top-level spec are always preserved as-is; that is,
if there is a colliding externally referenced object that needs to be
localized, that object will be renamed, not the local object with
which it collided. In the above example, the `Address` schema
occurring in _main.yaml_ will always retain its original name, forcing
any colliding objects to be renamed.

==== Recursive References

It is possible to set up recursive schema definitions in Swagger
specs, through the use of references. For example, consider the
following schema:

```
definitions:
  Person:
    type: object
    properties:
      name:
        type: string
      children:
         $ref: "#/definitions/People"  <1>
  People:
    type: array
    items:
      $ref: "#/definitions/Person"     <2>
```

<1> The `Person` schema has a `children` property of type `People`,
and
<2> the `People` schema defines an array of `Person` objects.

Naively attempting to inline a reference to a `Person` object would
lead to a never-ending expansion like this:

[source%nowrap]
.original
----
matriarch:
  $ref: "#/definitions/Person"
----

[source%nowrap]
.inlined
----
matriarch:
  type: object                 # inline Person
  properties:
    name:
      type: string
    children:
      type: array              # inline People
      items:
        type: object           # inline Person
        properties:
          name:
            type: string
          children:
            type: array        # inline People
            items:
               type: object    # inline Person
               ...             # inlining never ends
----

We have cut off the inlining above with an ellipsis, but in reality it
could never stop.

To handle recursive references encountered during inlining, the
normalizer stops inlining whenever a reference is encountered that is
fully contained within another (inlined) instance of the referenced
object. That recursive reference is localized rather than being
inlined.

In the above example, we would end up with something like this:

[source%nowrap]
.partially-inlined
----
    matriarch:
      type: object                            <1>
      properties:
	name:
	  type: string
	children:
	  type: array
	  items:
	    $ref: "#/definitions/Person"      <2>
...
definitions:
  Person:
    type: object
    properties:
      name:
        type: string
      children:
        type: array
        items:
          $ref: "#/definitions/Person"        <3>
  People:
    type: array
      items:
        type: object
        properties:
          name:
            type: string
          children:
            $ref: "#/definitions/People"      <4>
----

Here we see:

<1> that the top-level reference to `Person` as the type of
the `matriarch` property was inlined;
<2> that the recursive reference to `Person` encountered while
performing this inlining has been localized;
<3> the `Person` schema itself was subjected to inlining, with
localization of its recursive reference;
<4> and likewise for the `People` schema.

WARNING: For fragment references, recursive references are not currently
permitted and will cause the normalizer to fail.

== Object Retention

Some of the normalizer options pertain to _object retention policy_:
rules that decide which objects from the multifile spec will appear in
the normalized output.

The default retention policy is as follows:
* All objects that appear in the top-level model file are retained.
* All localized objects are retained.

Currently, there are two options that affect retention policy:

--
RETENTION_SCOPE:: Define the set of files from which objects are
eligible for retention. This option's value is a list of strings, each
of which may be any of the following:

[horizontal]
 .TOP::: Objects appearing in the top-level model file are in scope.

 .ALL::: Objects appearing in the top-level model file, and any other
model file that is reachable from the top-level model file via a
chain of references, are all in scope.

 _some URL_::: The model file identified by the URL is in scope, _even if
that file is not reachable from the top-level file_. This is
particularly helpful if your model includes _allOf_ subtypes. If you
collect all the subtypes in a separate file, you may find that none
of them are actually referenced from elsewhere in your
schema. Rather, each one references one or more supertypes, which
may be referenced from your model. Adding such a model file to the
retention scope directly ensures that the subtype schemas will
appear in the normalized spec. footnote:[If the URL is relative, it
will be interpreted relative to the top-level model file.]

The default retention scope is `[".TOP"]`.
--

DROP_UNREACHABLE_OBJECTS:: Indicates that if an object is not
reachable by reference chain from a path in the top-level model file,
it must not be retained - even if it came from the top-level model
file. However, if the normalized spec contains no paths, this option's
effect is canceled.
+
When *DROP_UNREACHABLE_OBEJCTS* is in effect (its value is _true_, and
the model has at least one path), it effectively forces the retention
scope to its default of `[".TOP"]`, since objects in the declared
scope but not in the default scope are provably unreachable.

== Normalizer Options

Options are configured in the GenTarget file (the `.gen` file created
by the GenTarget wizard). Each option can be set to a value. Most
options can be either _true_ or _false_.

Options are as follows:

INLINE_ALL:: Enable all the other INLINE options (and ignore
individual *INLINE_xxx* option settings).
+
Default: _false_

INLINE_DEFS:: Inline all schema definition references.
+
Default: _false_

INLINE_PARAMS:: Inline all parameter references.
+
Default: _true_

INLINE_RESPONSES:: Inline all response references.
+
Default: _true_

TIP: Note that there is no *INLINE_PATHS* option, since inlining is
the only meaningful handling of a path reference.

REWRITE_SIMPLE_REFS:: In former versions of the Swagger specification,
reference strings were allowed to take a simple form like `Pet`. These
would be treated as internal references based on the context in which
the reference appears. For example, in old pet-store examples,
references to the `Pet` schema appeared simply as `$ref: Pet` and this
would be equivalent to `$ref: #/definitions/Pet`.
+
While these "`simple references`" are no longer supported by the Swagger
specification, they are still processed by some existing
tools. Enabling this option will cause the normalizer to rewrite
simple references to fully compliant internal
references.footnote:[Simple reference strings are recognized only
if they start with an alphabetic character or "`\_`" and consist solely
of alpha-numeric characters and "`_`".]
+
Default: _true_

CREATE_DEF_TITLES:: This option causes the normalizer to add `title`
properties to definitions that do not already have them. The title for
such a definition is set to its property name in the `definitions`
object of its containing Swagger spec. This is particularly helpful
when name collisions occur during localization, as the titles then
reflect the original names of the definitions, prior to renaming.
+
Default: _false_

HOIST_MEDIA_TYPES:: This option causes the normalizer to copy
top-level `consumes` and `produces` property values into all
operations that do not supply their own values. The top-level lists
are removed from the normalized spec.
+
Default: _true_

HOIST_PATH_PARAMETERS:: This option causes parameters defined at
path-level to be copied into all that path's operations, except where
the operation directly defines a parameter with the same `name` and
`in` values. The path-level parameter definitions are removed from the
normalized spec.
+
Default: _true_

HOIST_SECURITY_REQUIREMENTS:: This option causes security requirements
appearing at top-level to be copied to all operations that do not
define their own security requirements.
+
Default: _true_

DROP_UNREACHABLE_OBJECTS:: If the normalized spec defines at least one
path object, this option causes all non-path objects that are not
reachable through reference chains starting in path objects to be
removed. When inlining options are in effect, this means that inlined
objects will be removed as free-standing objects, except in the case
of recursion. This option has no effect in the absence of path
objects, since the result would always be an empty spec.
+
Default: _false_

INSTANTIATE_NULL_COLLECTIONS:: There are many optional properties in
the Swagger specification, and the Swagger Java parser creates
structures in which omitted properties generally appear with `null`
values. This forces a great deal of null-checking in Java code that
processes parsed Swagger specs. The *INSTANTIATE_NULL_COLLECTIONS*
option causes such null values for either array-valued or
object-valued properties to be replaced with empty arrays and objects,
respectively, where doing so would not alter the meaning of the
spec.footnote:[An example of where such replacement would change the
spec is the `consumes` and `produces` arrays in operation
definitions. For these, an empty array would prevent inheriting the
corresponding global defaults, while a null value would not.]
+
Default: _true_

FIX_MISSING_TYPES:: The Swagger Java parser accepts Swagger specs in
which some object schemas are missing their `type` property. This is
allowed when the schema contains either a `properties` or
`additionalProperties` property. This option causes the normalizer to
fill in `type: object` in these cases.
+
Default: _true_

RETENTION_SCOPE:: A list of strings that identify model files whose
objects may appear in the normalized spec. Objects that are localized -
either by policy or to handle recursive inlining - are always
retained, regardless of retention scope. Objects that appear in
in-scope model files are also retained, unless retention is canceled
by *DROP_UNREACHABLE_OBJECTS* or some future drop policy option.
+
Allowed values include:
--
[horizontal]
 .TOP::: The top-level model file is in scope.
 .ALL::: The top-level model file, and any file containing an object
reachable from a top-level path, are all in scope.
 _some URL_::: The addressed file is in scope.
--
Default: [".TOP"]
