---
permalink: /swagger_normalizer/
---
= Using the Swagger Normalizer GenTemplate
:imagesdir: ../images/codegen
:linkattrs:
:docinfo2:
:RAS: RepreZen API Studio 
:RZ: RepreZen

Swagger Normalizer is a core component of the Swagger Multi-File
Support in {RAS}, and as such it is used by each of the three "`live`"
views - Documentation View, Diagram View, and Swagger UI View - that
appear by default in the right-hand pane of the {RAS} GUI, as well as
by all Swagger GenTemplates. You can also use it directly as its own
GenTemplate, named "`Swagger [Normalized YAML]`" in the GenTarget
Wizard. 

The primary function of the normalizer is to render a multi-file
Swagger spec as a functionally equivalent single-file spec. In this
way it can simplify the use of other tools and libraries in the
evolving Swagger ecosystem, where external references are not always
handled consistently.

Additionally, the normalizer can perform other transformations of the
Swagger spec, which may be helpful for some circumstances, especially
when feeding the spec to downstream systems.

== Basic Use

The Normalizer is used like any other Swagger GenTemplate:

1. Create a GenTarget (a `.gen` file) in your model folder, linking
your Swagger model file (`.yaml` file) to the GenTemplate. The
internal id of this GenTemplate is:
+
[source%nowrap]
--
com.modelsolv.reprezen.gentemplates.swaggernorm.SwaggerNormalizerGenTemplate
--
+
The name listed in the drop-down list in the GenTarget wizard is
"`Swagger [Normalizezd YAML].`"

2. Configure the GenTarget as desired (see below).

3. Execute the GenTarget

4. Find the generated YAML file in the `generated` folder that appears
in the GenTarget folder.

// Should have images walking through this process

== Multifile Processing

The one thing that the normalizer will always do is resolve external
references and leave you with a single-file Swagger Spec. The other
things it may do depend on options, described below.

=== Swagger References

Here's an example of what a typical _reference_ might look like in a
Swagger spec:

```
      responses:
        200:
          description: Default Response
	  schema:
	    $ref: "#/definitions/Pet"
```

This is part of the definition of an operation whose normal response
will contain data about a pet. That information will be structured
according to a schema named `Pet` defined elsewhere in this same
Swagger spec, in the `definitions` section of the spec.

The reference itself appears as the value of the `schema` property in
the response. That property could appear with an "in-line" schema
definition, but in this case the designer has opted to define the
schema elsewhere and reference it here by name.

If the definition of the `Pet` schema physically appeared in some
other Swagger spec, the reference would need to include a URL to
retrieve that spec, with a fragment identical to the reference string
shown above:

```
      responses:
        200:
          description: Default Response
	  schema:
	    $ref: "http://models.example.com/petstore-schemas.yaml#/definitions/Pet"
```


TIP: Swagger's `$ref` syntax conforms to a separate standard known as
"JSON Reference." That standard is available
https://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03[here].

=== What the Normalizer Does With References

References in a Swagger spec should all be of the variety specifically
endorsed by the http://swagger.io/specification[Swagger
Specification], namely those with URI fragments that begin with
`\#/paths/` or `#/parameters/` or `\#/responses/` or
`#/definitions/`. We'll call those _Swagger references_. All other
references will be called _fragment references_. Swagger Normalizer
does not treat these two varieties of reference identically.

WARNING: Fragment references are not officially allowed in Swagger
specs, but some tooling permits their use, and there are, confusingly,
posted examples and tutorials from Swagger project contributors that
feature them.

====
Note:: The document identified by the pre-fragment portion of an
external Swagger reference _must_ be a valid Swagger spec. At a
minimum this means that it must include: (1) a string-valued `swagger`
property whose value is `2.0`; (2) an object-valued `info` property
that includes (3) a string-valued `title` property and (4) a
string-valued `version` property; and an object-valued `paths` object,
which may be empty (`{}`). A minimal compliant Swagger spec
footnote:[The {RAS} New Model Wizard offers a "Minimal" option that
will create a (nearly) minimal Swagger spec as a starting point.]
might look like this:

```
---
swagger: "2.0" 
info: 
  title: My title
  version: "1.0"
paths: {}
```
====

For any given reference, there are two things that the normalizer
might do to the reference:

Inline:: In this case, the normalizer retrieves the referenced value
(e.g. the `Pet` schema definition object) and replaces the reference
itself with that value.

Localize:: In this case, the normalizer first adds the referenced
object to the single-file schema that it is creating, if it is not
already present, and then replaces the reference with a local
reference to that object. So in the external reference example shown
above, the `Pet` schema definition would appear directly in the
Swagger spec produced by the normalizer, and references that were
formerly external references would become local references.

The normalizer _always_ inlines fragment references. Any given Swagger
reference may be inlined or localized, depending on options in effect.

==== Name Collisions

Localization of a Swagger reference may lead to a name
collision. For example, imagine the the following excerpts from two
Swagger specs:

[source%nowrap]
.main.yaml
----
defintions:
  Address:
    description: An address given by a speaker
    type: object
    properties:
      speaker:
         $ref: "#/definitions/Speaker"
      title:
        type: string
      ...
  Speaker:
    name:
       type: string
    address:
      $ref: "external.yaml#/definitions/Address"
    ...
----

[source%nowrap]
.external.yaml
----
defintions:
  Address:
    description: A postal address
    type: object
    properties:
      street:
        type: string
      ...
  PhoneInfo:
    ... 
----


For example, a Swagger spec with a local definition named
`Pet` might include an external reference to a definition, also named
`Pet`, appearing in an extenal spec. In this case, the localized
version of that second definition named `Pet` will be named `Pet_1` in
the normalized spec. A third such definition referenced from some
other external spec, would be named `Pet_2`, and so on.

Renaming is done only where necessary due to a conflict, and the names
appearing in the top-level spec are always preserved as-is: if there
is a colliding externally referenced object that needs to be
localized, that object will be renamed, not the local object with
which it collided.

==== Recursive References

It is possible to set up recursive structures in Swagger specs,
through the use of references.

For Swagger references that would normally be inlined, localization is
performed when a recursive reference is encountered. For example, if a
response object is defined whose schema is a reference to a recursive
definition, then that definition will be inlined into the reference
itself, but the recursive reference encountered while inlining the
definition will be localized instead.

For fragment references, recursive references are not currently
permitted and will cause the normalizer to fail.

== Normalizer Options

Options are configured in the GenTarget file (the `.gen` file created
by the GenTarget wizard). Each option can be set to either `true` or
`false` as desired.

Options are as follows:

INLINE_ALL:: Enable all the other INLINE options.

INLINE_DEFS:: Inline all definitions references. (See discussion
regarding recursive references above.)

INLINE_PARAMS:: Inline all parameter references.

INLINE_RESPONSES:: Inline all response references.

TIP: Note that there is no `INLINE_PATHS` option, since the only
meaningful handling of a path reference is to inline it.

REWRITE_SIMPLE_REFS:: In former versions of the Swagger specification,
reference strings were allowed to take a simple form like `Pet`. These
would be treated as internal references based on the context in which
the reference appears. For example, in old pet-store examples,
references to the `Pet` schema appeared simply as `$ref: Pet` and this
would be equivalent to `$ref: #/definitions/Pet`.
+
While these "`simple references`" are no longer supported by the Swagger
specification, they are still processed by some existing
tools. Enabling this option will cause the normalizer to rewrite
simple references to fully compliant internal
references.footnote:[Simple reference strings are recognized only
if they start with an alphabetic character or "`\_`" and consist solely
of alpha-numeric characters and "`_`".]

CREATE_DEF_TITLES:: This option causes the normalizer to add `title`
properties to definitions that do not already have them. The title for
such a definition is set to its property name in the `definitions`
object of its containing Swagger spec. This is particularly helpful
when name collisions occur during localization, as the titles then
reflect the original names of the definitions, prior to renaming.

HOIST_MEDIA_TYPES:: This option causes the normalizer to copy
top-level `consumes` and `produces` property values into all
operations that do not supply their own values. The top-level lists
are removed from the normalized spec.

HOIST_PATH_PARAMETERS:: This option causes parameters defined at
path-level to be copied into all that path's operations, except where
the operation directly defines a parameter with the same name and `in`
value. The path-level parameter definitions are removed from the
normalized spec.

PRUNE_UNREFED_OBJECTS:: If the normalized spec defines at least one
path object, this option causes all non-path objects that are not
referenced in the normalized spec to be removed. When inlining options
are in effect, this means that inlined objects will be removed as
free-standing objects, except in the case of recursive use.

INSTANTIATE_NULL_COLLECTIONS:: There are many optional properties in
the Swagger specification, and the Swagger Java parser creates
structures in which omitted properties generally appear with `null`
values. This forces a great deal of null-checking in Java code that
processes parsed Swagger specs. This option causes such null values
for either array-valued or object-valued properties to be replaced
with empty arrays and objects, respectively, where doing so would not
alter the meaning of the spec.footnote:[An example of where such
replacement would chnage the spec is the `consumes` and `produces`
arrays in operation definitions. For these, an empty array would
prevent inheriting the corresponding global defaults.]

FIX_MISSING_TYPES:: The Swagger Java parser accepts Swagger specs in
which some object schemas are missing their `type` property. This is
allowed when the schema contains either a `properties` or
`additionalProperties` property. This option causes the normalizer to
fill in `type: object` in these cases.

USE_CODEGEN_OPTIONS:: Enabling this option causes the overall options
set to be configured as they would be for a normal GenTarget
execution. This option, unlike all other options, defauts to true.
+
The options implied by this option include: 
+
* REWRITE_SIMPLE_REFS
* INSTANTIATE_NULL_COLLECTIONS
* INLINE_PARAMS
* INLINE_REPSONSES
* HOIST_PATH_PARMS
* FIX_MISSING_TYPES

USE_DOC_OPTIONS:: Enabling this option casues the overall options set
to be configured as they would be for the Live Documentation view. The
options implied by this option include all those listed above for
*USE_CODEGEN_OPTIONS*, and also:
+
* CREATE_DEF_TITLES
* HOIST_MEDIA_TYPES
* PRUNE_UNREFED_OBJECTS
